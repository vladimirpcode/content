## Сырые сокеты (минимальный пример)

Когда-то давно я заинтересовался вопросом, как же мне передать данные по сети на языке программирования Pascal. Вышел разумеется я на сокеты - Беркли сокеты. И я такой не один. Эти штуки есть и на Linux и на Windows, а также в разных языках программирования, будь то Python или Java. Они позволяют нам передать данные (массив байт) из точки А в точку Б. Причем эти точки представлены IP адресом и номером порта. Номер порта - это просто число. Это нужно, чтобы данные попали не просто на компьютер, но нужной программе (процессу). Программа слушает нужный порт, а оправитель отсылает на него данные.

Погуглив мы найдем разные туториалы из известных процедур socket, bind, listen, accept, close.

## Зачем?

Но что, если мы хотим нечто большее чем просто отправить данные? А если мы хотим получить сетевой пакет полностью? И даже не пакет, а фрейм. А это уже практически самый низкий доступный программисту уровень сетевой модели OSI, ниже только физика. Сетевые карты разрабатывать программисту не приходится. А если мы хотим не только получить, но и полностью сконструировать свой собственный фрейм?

Ответ есть - это сырые сокеты! (Raw sockets!)

Зачем нам это? Мотивация может быть разной: обучение, любопытство, написание собственных сетевых приложений (VPN...), программных роутеров и коммутаторов, тестирование сетевого оборудования. Заманчиво, не так ли?

## Вводные
На борту Linux Fedora 37, C++

## К делу

Заголовочники:
```c++
#include <iostream>

#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <net/ethernet.h>
#include <cstring>
#include <linux/if_packet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <unistd.h>
```

В функции main: \
Создаем сырой сокет с помощью "привычной" функции `socket`, но с определенными параметрами.
```c++
int raw_socket = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
if (raw_socket < 0){
    std::cout << "не удалось создать сокет \n";
    return -1;
}
```

Далее важно определиться с именем сетевого интерфейса (порта на сетевой карте). В Linux смотрится командами типа `ip addr`, `ifconfig` и т.п.

```c++
const char interface_name[100] = "eth4";
```

Теперь запросим индекс интерфейса, он нам пригодится. Для запроса данных используем структуру `ifreq` и функцию для системного вызова `ioctl()`. После вызова `ioctl()` в определенном поле переменной `ifr` будет хранится значение индекса.
```c++
ifreq ifr;
memset(&ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_ifrn.ifrn_name, interface_name, IFNAMSIZ-1);
if (ioctl(raw_socket, SIOGIFINDEX, &ifr) == -1){
    std::cout << "не удалось получить индекс интерфейса\n";
    return -1;
}
int interface_index = ifr.ifr_ifru.ifru_ivalue;
```

Буква G в странной константе `SIOGIFINDEX` означает GET, а IFINDEX - Interface Index. \
Мы можем запросить и другие данные сетевого интерфейса - например, чтобы запросить MAC адрес нужно использовать константу `SIOCGIFHWADDR`. Будьте осторожны, `ifreq` на самом деле внутри представляет union, а значит одни и те же байты данных могут хранить значения разного типа. Сохраняйте нужные вам данные в отдельные переменные, сразу после вызова `ioctl()`, а также при запросе учтите, что при задании значений для нескольких полей - они могут перекрыть друг друга. Существуют макросы, для доступа к полям `ifreq` "покороче", например `ifr.ifr_name` вместо `ifr.ifr_ifrn.ifrn_name`.ifrn_name
```c++
//пример запроса MAC-адреса интерфейса
strncpy(ifr.ifr_ifrn.ifrn_name, interface_name, IFNAMSIZ-1);
if (ioctl(raw_socket, SIOCGIFHWADDR, &ifr) == -1){
    std::cout << "не удалось получить MAC-адрес интерфейса\n";
    return -1;
}
uint8_t mac[6];
//ETH_ALEN = длина MAC адреса = 6
memcpy(mac, ifreq_i.ifr_ifru.ifru_hwaddr.sa_data, ETH_ALEN); 
printf("MAC интерфейса: %x:%x:%x:%x:%x:%x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
```

Дальше нам понадобится в паре мест структура `sockaddr_ll` - аналог sockaddr в обычных сокетах. Привязываем сокет к нужному нам сетевому интерфейсу с помощью `bind()`, иначе он будет получать кадры со всех сетевых интерфейсов.

```c++
sockaddr_ll s_ll;
s_ll.sll_ifindex = interface_index;
s_ll.sll_family = AF_PACKET;

// пробуем прикрепить сокет к определенному порту (для отправки не обязательно)
if (bind(raw_socket, (sockaddr *)&s_ll, sizeof(s_ll)) == -1){
    std::cout << "не удалось привязать сокет к порту\n";
}
```

Отмечу, что в Интернете есть и другой способ привязать сокет к порту, но у меня он не сработал:

```c++
if (setsockopt(raw_socket, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) !=0){
    std::cout << "не удалось установить опцию сокета\n";
}
```

Теперь пробуем включить неразборчивый режим. Он необходим, чтобы наш сокет получал кадры с MAC-адресом получателя отличным от адреса нашего сетевого интерфейса. Есть опять же два способа. Один с использованием струтуры `mreq` и вызова `setsockopt()`, который используется для задания параметров сокета. Второй способ - просто "набрать нужную команду в консоли".

```c++
// пробуем включить неразборчивый режим (для отправки не обязательно)
packet_mreq mreq;
mreq.mr_ifindex = interface_index;
mreq.mr_type = PACKET_MR_PROMISC;
if (setsockopt(raw_socket, SOL_SOCKET, PACKET_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == -1){
    std::cout << "не удалось включить неразборчивый режим\n";
}
// у меня это не работает, поэтому я просто использую консольную команду через system():
using namespace std::string_literals;
std::string cmd = "ifconfig "s + std::string{interface_name} + " promisc"s;
system(cmd.c_str());
```

Переходим к приему и отправке сообщений:

Приготовим себе буффер (массив байт):
```c++
constexpr size_t BUFFSIZE = 65536;
uint8_t *buffer = (uint8_t*)malloc(BUFFSIZE);
memset(buffer, 0, BUFFSIZE);
```
    
Получение кадра. В качестве `sockaddr` можно использовать пустышку. Код напечатает MAC-адреса отправителя и получателя:
```c++
// получение кадра
sockaddr s;
int saddr_len = sizeof(s);
int bytes_received = recvfrom(raw_socket, buffer, BUFFSIZE, 0, &s, (socklen_t *)&saddr_len);
if (bytes_received > 0){
    printf("%x:%x:%x:%x:%x:%x -> %x:%x:%x:%x:%x:%x\n", buffer[6], buffer[7], buffer[8],
            buffer[9], buffer[10], buffer[11], buffer[0], buffer[1], buffer[2],
            buffer[3], buffer[4], buffer[5]);
}
```
    
Отправка кадра. Нам опять нужна структура `sockaddr_ll`, в которую нужно положить значение `AF_PACKET` и ранее полученный индекс сетевого интерфейса:
```c++
// отправка кадра
s_ll.sll_family = AF_PACKET;
s_ll.sll_ifindex = interface_index;
for (int i = 0; i < 64; ++i){
    buffer[i] = i;
}
int send_len = sendto(raw_socket, buffer, 64, 0, (sockaddr *)&s_ll, sizeof(s_ll));
if (send_len <= 0){
    std::cout << "отправка не удалась\n";
}
```
В папке рядом с этим файлом (`README.md`) лежит готовый C++ файл `main.cpp`. Компилируем его `g++ main.cpp -o app` и запускаем с правами суперпользователя `sudo ./app`. Смотрим результат.

## Примечание для пользователей Hyper-V. 
Если вы пишете код на виртуальной машине.

Чтобы ваша программа могла отправить кадр с MAC-адресом отличным от адреса вашего сетевого интерфейса в настройках виртуальной машины надо включить MAC-спуфинг: `файл->параметры`, выбираем нужный сетвой инетрфейс, жмем на плюсик, `дополнительные параметры` и ставим налочку на `включить спуфинг MAC адресов`. 

