## Консольный калькулятор на С++
Linux Fedora, Visual Studio Code, GCC (g++)
***
Искусству писать калькуляторы можно обучиться по замечательной книге Свердлова "Конструирование компиляторов" (Lambert-2015).

## Что мы хотим?
Написать парсер арифметических выражений. Вроде таких:
```
2 + 2
7 * 3 - 1
pi * R * R
7 + 4 * ((2 + 2) / (5 - (3 + 1)))
```
На борту +, -, /, *, скобки, целые числа и взаранее вручную заданные переменные.
## Как?
## Первый момент.
Напишем описание нашего языка-калькулятора в нотации РБНФ.
Проилюстрируем, что должна сделать программа и определим основные ее части.

Для чего описание? Так в книжке написано. Не будем пренебрегать опытом ученых мужей.

Сначала мы определяем общие части (блоки / сущности), а потом идем в сторону уточнения до тех пор пока не останутся сами цифры, числа, переменные, знаки и скобки. Последние назовем терминалами или токенами, а общие понятия нетерминалами. И так:
```
Выражение = Слагаемое {ОперСлож Слагаемое}
Слагаемое = Множитель {ОперУмнож Множитель}
Множитель = Число | Идентификатор | "(" Выражение ")"
```
Тут под оператором сложения имеется в виду и + и -, под оператором умножения и * и /. Остальные части понятны интуитивно, но определим и их:
```
ОперСлож = "+" | "-"
ОперУмнож = "*" | "/"
Число = Цифра {Цифра}
Идентификатор = Буква {Буква}
```
Цифру и букву определять не будем; пробелы игнорируются.
Не буду врать, это готовая схема. Правильно называть это грамматикой.

Для каждой такой сущности мы должны запрограммировать распознающую процедуру (функцию, метод). Эти процедуры для выражения `2 + 2 + 4` должны построить нам вот такое дерево:
```
      (+)
     /   \
   (+)   (4)
  /   \
(2)   (2)
```
При этом тот факт, что слагаемое у нас идет раньше множителя не случаен. Так для выражения `2 + 2 * 5` наша программа построит такое дерево.
```
   (+)
  /   \
(2)   (*)
     /   \ 
   (2)   (5)
```
Если же мы сначала будем распознавать множитель, то дерево будет таким:
```
      (*)
     /   \
   (+)   (5)
  /   \
(2)   (2)
```
При таком подходе нельзя обеспечить правильный для арифметики приоритет операций. Вычисление выражения будет идти снизу вверх, что мы увидим далее.
## Второй момент.
Для успешного распознования выражений нам понадобятся следующие блоки программы: 
1. поставщик исходного текста, который будет выкидывать для нас по одному символу и EOT когда символы закончатся.
2. лексический анализатор, который разобьет исходное выражение на лексемы (токены), такие как: Число, Идентификатор, +, /, ( и т. д.
3. синтаксический анализатор, который проверит, что лексемы идут в правильном порядке и построит на их основе дерево. Эта часть программы и будет действовать в соответствии с правилами нашего языка выражений.
4. вычислятор, который из полученного в предыдущем блоке дерева выдаст нам в ответ число, которое будет результатом выражения.

## Кодирование.
И так приступим. Первые два блока мы оформим в виде классов, а последние два в виде набора процедур.
### Программируем "драйвер" исходного текста
```c++
#include <iostream>
#include <string>

using namespace std;

int main(){
    string expr;
    cout << "Введите выражение: ";
    getline(cin, expr);    // вводим с клавиаутры
    
    return 0;
}
```
Это пустой макет, который ничего не делает.
Создадим класс Wrapper (обертка), который будет отвечать за выдачу текста по одному символу.
```c++
class Wrapper{
public:
    void next_char();   // считать следующий символ
    char ch;            // текущий символ
};
```
Пробелы в нашем случае не нужны и мы их будем просто пропускать. Определим в нашем классе конструктор, принимающий строку. Он будет вызывать метод `next_char()` и таким образом при создании объекта будет считан и доступен первый символ выражения. 
```c++
class Wrapper{
public:
    Wrapper(string _data){
        data = _data;
        pos = 0;
        next_char();
    }

    void next_char();   // считать следующий символ
    char ch;            // текущий символ
    
private:
    string data;
    int pos;            // номер следующего символа
};
```
Осталось запрограммировать метод `next_char()`. Для обозначения конца текста определим константу `char EOT = 3`, что соотвествует символу конца текста в таблице символов ASCII (https://snipp.ru/handbk/table-ascii). К ней мы еще обратимся.
```
void next_char(){
    Если текст закончился:
        присвоить текущему символу значение EOT
        возврат из метода
    Конец Если

    Присвоить текущему символу следующее значение.
    
    Пока текущий символ является пробелом 
         и текст не закончился:
        Присвоить текущему символу следующее значение
    Конец Пока
    
    Если символ является пробелом:
        присвоить текущему символу значение EOT
        возврат из метода
    Конец Если

    // если символ не пробел, значит мы вышли из цикла потому, что текст закончился. А это значит что текущий символ будет корректным непробельным символом
}
```
Тоже самое на C++:
```c++

constexpr char EOT = 3;    // <-----

class Wrapper{
public:
    Wrapper(string _data){
        data = _data;
        pos = 0;
        next_char();
    }

    void next_char(){   // считать следующий символ
        if (pos == data.length()){
            ch = EOT;
            return;
        }
        ch = data[pos];
        pos++;
        while (is_whitespace(ch) && pos < data.length()){
            ch = data[pos];
            pos++;
        }
        if (is_whitespace(ch)){
            ch = EOT;
            return;
        }
    }

    char ch;            // текущий символ
    
private:
    string data;
    int pos;            // номер следующего символа
};
```
Программируем функцию `is_whitespace(char c)`, которая на основании кода символа определит явялется ли символ пробелом. Для этого сравним его с кодом пробела (32) и горизонтальной табуляции (9). Функцию размещаем вне класса (в глобальном пространстве). В случае Java или C# можно создать отдельный класс `Utils` для размещений подобных функций. 
```c++
bool is_whitespace(char c){
    return c == 9 || c == 32;   // 9 - TAB, 32 - space
}
```
Проверим как это работает:
```c++
int main(){
    string expr;
    cout << "Введите выражение: ";
    getline(cin, expr);
    // временный проверочный код
    Wrapper* wrap = new Wrapper(expr);
    while (wrap->ch != EOT){
        cout << "[" << wrap->ch << "], ";
        wrap->next_char();
    }
    cout << "\n";
    delete wrap;
    return 0;
}
```
При вводе `2 + 2 = 4` видим: 
```
[2], [+], [2], [=], [4], 
```
Примечение: \
Код `Wrapper* wrap = new Wrapper(expr);` со звездочкой по смыслу примерно соответствует обычным ссылочным объектам Java и C#: `Wrapper wrap = new Wrapper(expr);`. (Звездочка используется для объявления указателей). Оператор `->` в данном контексте делает то же, что и точка "`.`"для доступа к членам класса в C# и Java. Точка есть и в С++, но в нем объекты могут быть НЕ ссылочными переменными.
### Программируем лексический анализатор
Токены для нас будет предоставлять другой класс под названием `Lexer`, который будет содержать объект типа Wrapper. Мы же будем получать уже готовые лексемы. Но сначала создадим перечисление (enum), которое будет описывать все лексемы, включая переменные и конец текста.
```c++
enum class Lex{
    NUMBER,     // Число
    IDENT,      // Идентификатор
    PLUS,       // +
    MINUS,      // -
    EQUAL,      // =
    MULTIPLY,   // *
    DIVIDE,     // /
    LBRACE,     // (
    RBRACE,     // )
    EOT,        // Конец текста
    NONE        // Отсутствие лексемы
};
```
Интерфейс класса `Lexer` (т.е. публичные методы и переменные):
```c++
class Lexer{
public:
    Lexer(string s):wrap(s){
        next_lex();
    }
    Lex token;
    int number_value;   // на случай если лексема - число
    string name;        // на случай если лексема - идентификатор
    void next_lex();
};
```
Конструктор будет принимать строку и на ее основе создавать объект класса `Wrapper`. Он достаточно прост:
```c++
    ...
    Lexer(string s):wrap(s){
        next_lex();
    }
```
Здесь также автоматически запрашивается первая лексема. Вручную этого делать не нужно. Синтаксис `:wrap(s)` в мире С++ это как если в C# и Java написать в конструкторе `wrap = new Wrapper(s)`. wrap - объект типа Wrapper:
```c++
private:
    Wrapper wrap;
```
Программируем метод `next_lex()`:
```
void next_lex(){
    Если текущий символ буква
        Вызвать распознающую процедуру для имени
        сохранить имя
        установить токен в значение идентификатора
    Иначе Если текущий символ цифра
        Вызвать распознающую процедуру для числа
        сохранить число
        установить токен в значение числа
    Иначе
        Устанавливаем токен в значение соответствующее легальному символу
        Если символ не известен, вывести ошибку.
    Конец Если
}
```
На C++:
```c++
class Lexer{
public:
    Lexer(string s):wrap(s){
        next_lex();
    }
    Lex token;
    int number_value;   // на случай если лексема - число
    string name;        // на случай если лексема - идентификатор
    void next_lex(){
        if (is_alpha(wrap.ch)){
            name = ident();
            token = Lex::IDENT;
        } else if(is_number(wrap.ch)){
            number_value = number();
            token = Lex::NUMBER;
        } else {
            switch (wrap.ch){
                case '+': token = Lex::PLUS; break;
                case '-': token = Lex::MINUS; break;
                case '*': token = Lex::MULTIPLY; break;
                case '/': token = Lex::DIVIDE; break;
                case '(': token = Lex::LBRACE; break;
                case ')': token = Lex::RBRACE; break;
                case '=': token = Lex::EQUAL; break;
                case EOT: token = Lex::EOT; break;
                default: error("неизвестный токен");
            }
            wrap.next_char();
        }
    }
private:
    Wrapper wrap;
};
```
Распознающие процедуры для имени и числа размещаем в закрытой части класса:
```c++
class Lexer{
public:
    ...
private:
    Wrapper wrap;

    string ident(){
        string result = "";
        while (is_alpha(wrap.ch)){
            result = result + wrap.ch;
            wrap.next_char();
        }
        return result;
    }
    
    int number(){
        int result = 0;
        while (is_number(wrap.ch)){
            // 48 - код нуля (0) по таблице ASCII
            // преобразуем символ в цифру 
            result = result * 10 + (wrap.ch - 48); 
            wrap.next_char();
        }
        return result;
    }
};
```
Программируем недостающие процедуры для вывода ошибок и для определения является ли символ цифрой / буквой. Согласно таблице символов ASCII символы цифр '0'-'9' представлены кодами 48-57, а буквы 'A'-'Z', 'a'-'z' - кодами 65-90, 97-122. 
```c++
void error(string msg){
    cout << "Ошибка: " << msg << endl;
    exit(-1);
}

void expected(string msg){
    cout << "Ожидалось " << msg << endl;
    exit(-2);
}

bool is_whitespace(char c){
    return c == 9 || c == 32;   // 9 - TAB, 32 - space
}

bool is_number(char c){
    return c >= 48 && c <= 57;
}

bool is_alpha(char c){
    return (c >= 65 && c <= 90) || (c >= 97 && c <= 122);
}
```
Проверяем:
```c++
int main(){
    string expr;
    cout << "Введите выражение: ";
    getline(cin, expr);
    // временный проверочный код
    Lexer* lexer = new Lexer(expr);
    while (lexer->token != Lex::EOT){
        cout << static_cast<int>(lexer->token) << " ";
        lexer->next_lex();
    }
    cout << "\n";
    delete lexer;
    return 0;
}
```
Смотрим:
```
Введите выражение: 2 + 2 = 4
0 2 0 4 0 
```
Да, это не очень наглядно. Но смею Вас заверить, эти номера точно соответствуют нужным элементам перечисления Lex. К сожалению это не питон. Но если кто желает, можно написать соответствующий switch {case Lex::PLUS: ....} для наглядности.

Примечание: \
Синтаксис `Lex::PLUS` с двумя двоеточиями служит для доступа к элементу перечисления и по смыслу соответствует точке в других языках программирования: `Lex.PLUS`  \
`static_cast<int>` в данном случае нужен для преобразования элемента перечисления в число (его номер).
## Синтаксический анализатор
Мы все ближе подходим к главному. Эта часть программы будет для нас строить то самое деревце с числами и арифметическими операциями.

Синтаксический анализатор (парсер) программируется в соответствии с описанной ранее грамматикой в нотации РБНФ:
```
Выражение = Слагаемое {ОперСлож Слагаемое}
Слагаемое = Множитель {ОперУмнож Множитель}
Множитель = Число | Идентификатор | "(" Выражение ")"
ОперСлож = "+" | "-"
ОперУмнож = "*" | "/"
Число = Цифра {Цифра}
Идентификатор = Буква {Буква}
```
Каждому нетерминалу будет соответствовать процедура. Хотя для простых нетерминалов мы отдельную процедуру программировать не будем:
```c++
// Выражение = Слагаемое {ОперСлож Слагаемое}
void expression(){
    term();     //слагаемое
    while(lexer->token == Lex::MINUS || lexer->token == Lex::PLUS){
        lexer->next_lex();
        term();
    }
}
```
Отмечу что для работы распознающих процедур нам потребуется создать глобальную переменную типа `Lexer`. Пока что мы ее просто объявим:
```c++
Lexer* lexer;

// Выражение = Слагаемое {ОперСлож Слагаемое}
void expression(){
...
```
Перед программированием дальнейших процедур следует обсудить где мы будем хранить имена и значения предзаданных переменных (фактически констант). Для этой цели мы заведем глобальный объект `variables`, который будет иметь тип `map<string, double>`. Не забудьте `#include <map>` в начале файла:
```c++
#include <map>
...
...
Lexer* lexer;
map<string, double> variables;

// Выражение = Слагаемое {ОперСлож Слагаемое}
void expression(){
    ...
```

Запрограммируем оставшиеся процедуры
```c++
//Слагаемое = Множитель {ОперУмнож Множитель}
void term(){
    factor();
    while (lexer->token == Lex::MULTIPLY || lexer->token == Lex::DIVIDE){
        lexer->next_lex();
        factor();
    }
}

//Множитель = Число | Идентификатор | "(" Выражение ")"
void factor(){
    if (lexer->token == Lex::NUMBER){
        lexer->next_lex();
    }
    else if (lexer->token == Lex::IDENT){
        // C++ способ найти значение в map. 
        // В других языках по другому.
        if (variables.find(lexer->name) == variables.end()){
            error("имя  не существует");
        }
        lexer->next_lex();
    }
    else if (lexer->token == Lex::LBRACE){
        lexer->next_lex();
        expression();
        if (lexer->token != Lex::RBRACE){
            expected(")");
        }
        lexer->next_lex();
    } 
}
```
Поскольку процедура `expression` вызывает процедуру `term`, вызывающую `factor`, который в свою очередь может вызвать `expression` нам необходимо продублировать объявления методов `term` и `factor` над определением `expression`. Это особенность С++:
```c++
...
map<string, double> variables;

void term();
void factor();

// Выражение = Слагаемое {ОперСлож Слагаемое}
void expression(){
    ...
```
Проверяем как работает:
```c++
int main(){
    string expr;
    cout << "Введите выражение: ";
    getline(cin, expr);

    variables["myVar"] = 100;
    variables["pi"] = 3.14;
    lexer = new Lexer(expr);
    expression();
    if (lexer->token != Lex::EOT){
        expected("EOT");
    }
    cout << "__________OK\n";
    delete lexer;
    
    return 0;
}
```
```
Введите выражение: pi * 100
__________OK

Введите выражение: 2 * 7 / (2 + 4 - 50 * (myVar*100))        
__________OK

Введите выражение: anyVar + 1
Ошибка: имя  не существует

Введите выражение: #@!#!@gdf
#Ошибка: неизвестный токен

Введите выражение: (2 + 1
Ожидалось )

Введите выражение: (2+1))
Ожидалось EOT
```
## Реализация вычисления выражения
Пока что наша программа только проверяет соответствует ли входная строка легальному выражения или нет и ничего не вычисляет. Пора это исправить. Как уже было оговорено парсер будет строить нам дерево. Самое время это дерево запрограммировать.

ТЗ: класс `Node` должен представлять элемент дерева, который должен указывать на своих двух потомков (левый и правый). Должен содержать числовое значение и тип операции. В один момент времени будем использовать или то или то. 

Вуаля:
```c++
class Node{
public:
    Node* left;
    Node* right;
    Lex operation;
    double value;

    Node(){
        left = nullptr;
        right = nullptr;
        operation = Lex::NONE;
        value = 0;
    }

    ~Node(){
        if (left != nullptr){
            delete left;
        }
        if (right != nullptr){
            delete right;
        }
    }
};
```
Для типа операции сгодилось уже существующее перечисление Lex, которое описывает все нужные нам операции.

Проилюстрируем процесс построения дерева на примере выражения \
`2 + 2 * 7`:
```
1) expression()                      |
        v                            |
       term()                        |
        v                            |
      factor()                       |  (2)

2) expression()  видим "+"           |
        v     ^                      |
       term()                        |     (+)
        v     ^                      |    /
      factor()                       |  (2)

3) expression()                      |
        v     ^     v                |
       term()     term()             |     (+)
        v     ^     v                |    /   \ 
      factor()    factor()           |  (2)   (2)

4) expression()                      |
        v     ^     v                |
       term()     term()   видим "*" |     (+)
        v     ^     v    ^           |    /   \ 
      factor()    factor()           |  (2)   (*)
                                     |       /  
                                     |     (2)

5) expression()                      |
        v     ^     v                |
       term()     term()             |     (+)
        v     ^     v    ^    v      |    /   \ 
      factor()    factor()  factor() |  (2)   (*)
                                     |       /   \
                                     |     (2)   (7)
```
Как видно построением дерева и заполнением его значениеями занимаются процедуры парсера. Но чтобы такое провернуть мы должны передать им ту ноду (Node), которую они должны построить. При первом вызове `expression()` мы должны передать корень дерева. Передавать будем указатель на `Node`. В С# и Java это то же, что обычный ссылочный объект. Но вдобавок ко всему этому мы должны передавать указатель по ссылке! То есть так чтобы изменения самой переменной-указателя распространялись за пределы процедур. В С# для этого служит ключевое слово `ref` при передаче параметров в метод. Альтернатива: возвращать Node через `return` и следить, чтобы значение было сохранено куда нужно.

Условимся, что каждая процедура получает на вход инициализированный указатель на `Node`. То есть объект должен быть взаранее создан в памяти. Передача нулевых указателей (`nullptr`) воспрещается.

Внесем изменения в объявления и определения методов `expression`, `term` и `factor`. Теперь они должны выглядеть так:
```c++
void term(Node *&node);
void factor(Node *&node);

// Выражение = Слагаемое {ОперСлож Слагаемое}
void expression(Node *&node){
...
//Слагаемое = Множитель {ОперУмнож Множитель}
void term(Node *&node){
...
//Множитель = Число | Идентификатор | "(" Выражение ")"
void factor(Node *&node){
```
Примечание: `Node *&node` (переменная-указатель, передаваемая по ссылке) в C# будет записываться как объект, передаваемый с ключевым словом `ref` (по ссылке): `expression(ref Node node)`

Каким образом будем действовать? Каждая процедура целиком и полностью будет отвечать за построение своей части дерева. То есть мы отдаем процедуре ноду и можем быть уверены, что она корректно построит свою часть дерева.

Но у каждой ноды всего два потомка, а слагаемых (множителей) может быть больше двух и все они обрабатываюстя в цикле.

Каждый раз когда процедуры натыкаются на знаки +, -, *, / они должны создать новую ноду. Старую подцепить к ней слева (так как порядок выполнения слева направо). И присвоить переменной `node` эту новосозданную ноду, таким образом как будто так и было. При этом вышестоящий вызывающий код получает корректную часть дерева, ничего об этом не зная. Поэтому мы и передавали переменную-указатель по ссылке (`ref` в C#).

Илюстрация на примере 2 + 3 + 4:
```
1)      (2)

2)      (+)
       /
     (2) <--- ушла вниз

3)      (+)
       /   \
     (2)   (3)

4)         (+)
          /
        (+)  <--- ушла вниз
       /   \
     (2)   (3)

5)         (+)
          /   \
        (+)   (4)
       /   \
     (2)   (3)
```

Учитывая, что вычисление идет снизу вверх, на рисунке у нас получился правильный порядок вычислений операций (слева направо). 

```c++
// Выражение = Слагаемое {ОперСлож Слагаемое}
void expression(Node *&node){
    term(node);     //слагаемое
    while(lexer->token == Lex::MINUS || lexer->token == Lex::PLUS){
        Node *tmp = node;               // запоминаем старое поддерево
        node = new Node();              // создаем новую ноду
        node->operation = lexer->token; // не забываем про операцию
        node->left = tmp;               // подцепляем старое поддерево слева
        lexer->next_lex();
        node->right = new Node();       // по соглашению создаем объект в памяти заранее
        term(node->right);              // правую часть дерева отдаем на откуп term()
    }
}
```

Программируем оставшиеся процедуры в том же ключе, не забывая присваивать числовые значение или тип операции.

```c++
//Слагаемое = Множитель {ОперУмнож Множитель}
void term(Node *&node){
    factor(node);
    while (lexer->token == Lex::MULTIPLY || lexer->token == Lex::DIVIDE){
        Node *tmp = node;
        node = new Node();
        node->left = tmp;
        node->operation = lexer->token;
        lexer->next_lex();
        node->right = new Node();
        factor(node->right);
    }
}

//Множитель = Число | Идентификатор | "(" Выражение ")"
void factor(Node *&node){
    if (lexer->token == Lex::NUMBER){
        node->value = lexer->number_value;      // не забываем числовое значение
        lexer->next_lex();
    }
    else if (lexer->token == Lex::IDENT){
        // C++ способ найти значение в map. 
        // В других языках по другому.
        if (variables.find(lexer->name) == variables.end()){
            error("имя  не существует");
        }
        node->value = variables[lexer->name];   // не забываем значение переменной
        lexer->next_lex();
    }
    else if (lexer->token == Lex::LBRACE){
        lexer->next_lex();
        expression(node);
        if (lexer->token != Lex::RBRACE){
            expected(")");
        }
        lexer->next_lex();
    } 
}
```

Далее будем проводить разведку боем. Сразу реализуем процедуру вычисления и начнем проверять программу.

Для этого нужно воспользоваться рекурсией. Как только наша рекурсия дойдет до дна дерева она должна вернуть результат (числовое значение). И при этом на каждом этапе должны производится определенные операции с левой и правой частью дерева. Числовой результат операции должен возвращаться через `return`

```c++
double calculate(Node* node){
    Если левая и правая части узла пустые: 
        вернуть значение узла.
    Конец Если

    Вычислить левую часть дерева. (calculate(node->left))
    Вычислить правую часть дерева.  (calculate(node->right))

    Выполнить операцию над результатами вычислений.
    Вернуть результат
}
```
С++
```c++
double calculate(Node* node){
    if (node->left == nullptr && node->right == nullptr){
        return node->value;
    }
    double left_result = calculate(node->left);
    double right_result = calculate(node->right);
    switch (node->operation){
        case Lex::PLUS: return left_result + right_result;
        case Lex::MINUS: return left_result - right_result;
        case Lex::DIVIDE: return left_result / right_result;
        case Lex::MULTIPLY: return left_result * right_result;
        default: error("неизвестная операция. Вычисление не удалось");
    }
    return 0;
}
```
Добавляем необходимые детали в наш гланый код
```c++
int main(){
    string expr;
    cout << "Введите выражение: ";
    getline(cin, expr);

    variables["myVar"] = 100;
    variables["pi"] = 3.14;
    lexer = new Lexer(expr);
    Node* tree_root = new Node();   // создаем корень дерева
    expression(tree_root);
    if (lexer->token != Lex::EOT){
        expected("EOT");
    }
    double result = calculate(tree_root);   // вычисляем выражение
    cout << " = " << result << "\n";
    cout << "__________OK\n";
    delete lexer;
    
    return 0;
}
```
Результат таков:
```
Введите выражение: pi * 2
 = 6.28
__________OK

Введите выражение: 1 + 1 * (2 * pi) / (3 - 1 * myVar - (7 + 10))
 = 0.944912
__________OK

Введите выражение: (2+2)* (7+1) - pi
 = 28.86
__________OK
```
(Это правильные ответы)

## Зачем это все?
~~ДЛЯ КОНТЕНТА~~

Возможно кто-то заинтересуется темой парсинга (настоящего) и даже компиляции.

Парсинг можно применить в таких случаях:

1. Вы пишете консоль (CLI) к своей программе.
2. Вы определяете нестандартный текстовый формат файла для хранения данных. (не XML, JSON)
3. Для построения мини-языков, например для описания тестов в специфичной области. 

А если погрузиться в тему компиляции, можно создать свой язык, пойти работать в этой области (я не говорил, что это будет легко). Да и вообще компиляция это олд-скульная часть обучения программиста.